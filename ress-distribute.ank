/*
 * ===================================================================
 * AUTOMATED RESOURCE DISTRIBUTION SYSTEM
 * ===================================================================
 * 
 * Description: 
 *   Intelligent resource distribution script that automatically 
 *   balances Metal, Crystal, and Deuterium across all planets and 
 *   moons every 3 hours. Features smart fleet management, slot 
 *   monitoring, and robust error handling.
 *
 * Features:
 *   - Automatic execution every 3 hours
 *   - Calculates optimal resource averages
 *   - Intelligent cargo ship allocation
 *   - Fleet slot availability checking
 *   - Robust error handling and recovery
 *   - Works with both planets and moons
 *   - Integrates seamlessly with Brain system
 *
 * Configuration:
 *   - splitMetal: true (distribute metal)
 *   - splitCrystal: true (distribute crystal) 
 *   - splitDeuterium: true (distribute deuterium)
 *   - roundFactor: 500,000 (minimum transfer amount)
 *   - Execution interval: 3 hours
 *
 * Author: BenLue
 * Created: 2025
 * Version: 1.0
 * Compatible with: OGame.ninja API
 * 
 * ===================================================================
 */

splitPlanetWorkers = "allPlanets"
splitMetal       = true
splitCrystal     = true  
splitDeuterium   = true
roundFactor      = 500000

func doWork() {
    LogInfo("üîÑ Starting simple resource distribution...")
    
    // Get all planets and moons
    allCelestials = []
    planets = GetCachedPlanets()
    moons = GetCachedMoons()
    
    // Add planets to list
    for p in planets {
        allCelestials = allCelestials + [p]
    }
    
    // Add moons to list
    for m in moons {
        allCelestials = allCelestials + [m]
    }
    
    if len(allCelestials) == 0 {
        LogError("‚ùå No celestials found!")
        return
    }
    
    LogInfo("üìç Found", len(allCelestials), "celestials")
    
    // Calculate total resources and average
    totalMetal = 0
    totalCrystal = 0 
    totalDeut = 0
    celestialData = []
    
    for cel in allCelestials {
        res = cel.GetResources()[0]
        totalMetal = totalMetal + res.Metal
        totalCrystal = totalCrystal + res.Crystal
        totalDeut = totalDeut + res.Deuterium
        
        celData = {}
        celData["cel"] = cel
        celData["res"] = res
        celestialData = celestialData + [celData]
        
        Sleep(Random(300,600))
    }
    
    avgMetal = totalMetal / len(allCelestials)
    avgCrystal = totalCrystal / len(allCelestials)
    avgDeut = totalDeut / len(allCelestials)
    
    LogInfo("üìä Averages - Metal:", Dotify(avgMetal), "Crystal:", Dotify(avgCrystal), "Deuterium:", Dotify(avgDeut))
    
    // Find who needs what and who can give
    needers = []
    givers = []
    
    for data in celestialData {
        cel = data["cel"]
        res = data["res"]
        
        needMetal = 0
        needCrystal = 0
        needDeut = 0
        
        if splitMetal && res.Metal < avgMetal {
            needMetal = avgMetal - res.Metal
        }
        if splitCrystal && res.Crystal < avgCrystal {
            needCrystal = avgCrystal - res.Crystal
        }
        if splitDeuterium && res.Deuterium < avgDeut {
            needDeut = avgDeut - res.Deuterium
        }
        
        if needMetal > 0 || needCrystal > 0 || needDeut > 0 {
            needer = {}
            needer["cel"] = cel
            needer["needMetal"] = needMetal
            needer["needCrystal"] = needCrystal
            needer["needDeut"] = needDeut
            needers = needers + [needer]
        }
        
        canGiveMetal = 0
        canGiveCrystal = 0
        canGiveDeut = 0
        
        if splitMetal && res.Metal > avgMetal {
            canGiveMetal = res.Metal - avgMetal
        }
        if splitCrystal && res.Crystal > avgCrystal {
            canGiveCrystal = res.Crystal - avgCrystal
        }
        if splitDeuterium && res.Deuterium > avgDeut {
            canGiveDeut = res.Deuterium - avgDeut
        }
        
        if canGiveMetal > 0 || canGiveCrystal > 0 || canGiveDeut > 0 {
            giver = {}
            giver["cel"] = cel
            giver["canGiveMetal"] = canGiveMetal
            giver["canGiveCrystal"] = canGiveCrystal
            giver["canGiveDeut"] = canGiveDeut
            givers = givers + [giver]
        }
    }
    
    LogInfo("üéØ Found", len(needers), "needers and", len(givers), "givers")
    
    // Match needers with givers and create transfers
    for needer in needers {
        needCel = needer["cel"]
        needMetal = needer["needMetal"]
        needCrystal = needer["needCrystal"] 
        needDeut = needer["needDeut"]
        
        LogInfo("üîç Processing needs for", needCel.Coordinate)
        
        for giver in givers {
            giveCel = giver["cel"]
            canGiveMetal = giver["canGiveMetal"]
            canGiveCrystal = giver["canGiveCrystal"]
            canGiveDeut = giver["canGiveDeut"]
            
            if needCel.Coordinate.Equal(giveCel.Coordinate) { continue }
            if needMetal <= 0 && needCrystal <= 0 && needDeut <= 0 { break }
            if canGiveMetal <= 0 && canGiveCrystal <= 0 && canGiveDeut <= 0 { continue }
            
            sendMetal = 0
            sendCrystal = 0
            sendDeut = 0
            
            if needMetal > 0 && canGiveMetal > 0 {
                sendMetal = Min(needMetal, canGiveMetal)
                needMetal = needMetal - sendMetal
                giver["canGiveMetal"] = canGiveMetal - sendMetal
            }
            
            if needCrystal > 0 && canGiveCrystal > 0 {
                sendCrystal = Min(needCrystal, canGiveCrystal)
                needCrystal = needCrystal - sendCrystal
                giver["canGiveCrystal"] = canGiveCrystal - sendCrystal
            }
            
            if needDeut > 0 && canGiveDeut > 0 {
                sendDeut = Min(needDeut, canGiveDeut)
                needDeut = needDeut - sendDeut
                giver["canGiveDeut"] = canGiveDeut - sendDeut
            }
            
            // Apply rounding
            sendMetal = Floor(sendMetal/roundFactor) * roundFactor
            sendCrystal = Floor(sendCrystal/roundFactor) * roundFactor
            sendDeut = Floor(sendDeut/roundFactor) * roundFactor
            
            totalToSend = sendMetal + sendCrystal + sendDeut
            
            if totalToSend > 0 {
                LogInfo("üì¶ Sending from", giveCel.Coordinate, "to", needCel.Coordinate)
                LogInfo("üìã Metal:", Dotify(sendMetal), "Crystal:", Dotify(sendCrystal), "Deuterium:", Dotify(sendDeut))
                
                // Check fleet slots availability
                fleets, slots = GetFleets()
                if slots.InUse >= slots.Total {
                    LogWarn("‚è≥ All fleet slots in use (", slots.InUse, "/", slots.Total, "). Waiting 2 minutes...")
                    Sleep(120000) // Wait 2 minutes
                    
                    // Check again after waiting
                    fleets, slots = GetFleets()
                    if slots.InUse >= slots.Total {
                        LogWarn("‚è∏Ô∏è  Still no slots available. Skipping this transfer.")
                        continue
                    }
                }
                
                // Check if sender has enough cargo ships
                ships, err = giveCel.GetShips()
                if err != nil {
                    LogError("‚ùå Could not get ships info:", err)
                    continue
                }
                
                cargoNeeded = Ceil(totalToSend / 25000) // Large Cargo holds 25k resources
                availableCargo = ships.LargeCargo + (ships.SmallCargo / 2) // Small cargo = half a large cargo
                
                if availableCargo < cargoNeeded {
                    LogWarn("‚ö†Ô∏è  Not enough cargo ships available. Need:", cargoNeeded, "Available:", availableCargo)
                    continue
                }
                
                // Create fleet with cargo ships for transport  
                fleet = NewShipsInfos()
                if ships.LargeCargo >= cargoNeeded {
                    fleet.LargeCargo = cargoNeeded
                } else {
                    fleet.LargeCargo = ships.LargeCargo
                    remainingCargo = cargoNeeded - ships.LargeCargo
                    fleet.SmallCargo = remainingCargo * 2
                }
                
                // Use the correct Celestial.SendFleet method
                resources = NewResources(sendMetal, sendCrystal, sendDeut)
                sentFleet, err = giveCel.SendFleet(*fleet, HUNDRED_PERCENT, needCel.GetCoordinate(), TRANSPORT, resources, 0, 0)
                
                if err != nil {
                    LogError("‚ùå Send failed:", err)
                    if err.Error() == "all slots are in use" {
                        LogInfo("‚è≥ Waiting for fleet slots to become available...")
                        Sleep(300000) // Wait 5 minutes for fleets to return
                    }
                } else {
                    LogInfo("‚úÖ Fleet sent successfully - ID:", sentFleet.ID)
                }
                
                Sleep(Random(15000,30000))
            }
        }
        
        // Update the needer's remaining needs
        needer["needMetal"] = needMetal
        needer["needCrystal"] = needCrystal
        needer["needDeut"] = needDeut
    }
    
    LogInfo("‚úÖ Resource distribution completed!")
}

// TIMING SETUP - Resource distribution every 3 hours (Optimal)
LogInfo("üïê Setting up automatic resource distribution every 3 hours...")
IntervalExec(3 * 3600000, doWork) // 3 hours = 10,800,000 ms

// Alternative timing options (commented out):
// IntervalExec(6 * 3600000, doWork) // Every 6 hours
// IntervalExec(12 * 3600000, doWork) // Every 12 hours  
// CronExec("0 0 8,14,20 * * *", doWork) // 8 AM, 2 PM, 8 PM daily

// Run once immediately, then wait for scheduled executions
doWork()

// Keep the script running
<-OnQuitCh
